<!DOCTYPE html>
<html lang="zh-HK">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
	<title>Vanilla JS TetrisÔºàÊ•µÁ∞°Ëß∏ÊéßÁâàÔºâ</title>
	<style>
		body {
			margin: 0; padding: 10px; background: #0a0a0a; color: #fff;
			font-family: 'Courier New', monospace;
			display: flex; flex-direction: column; justify-content: center; align-items: center;
			min-height: 100vh; overflow: auto; box-sizing: border-box;
		}
		#game {
			display: flex; flex-direction: column; align-items: center; gap: 0;
			width: 100%; max-width: 400px;
		}
		#top-panel {
			width: 100%; max-width: 400px; text-align: center;
			margin-bottom: 0;
		}
		#info {
			display: flex; justify-content: space-between; align-items: center;
			gap: 10px; margin: 0 0 8px 0; font-size: 0.95em; font-weight: bold;
			background: #111; padding: 8px 12px; border-radius: 8px 8px 0 0;
			border: 4px solid #333; border-bottom: none;
		}
		#score-item {
			flex: 2; background: #222; padding: 6px 16px; border-radius: 6px;
			text-align: center; min-width: 120px;
		}
		#level-item {
			flex: 1; background: #222; padding: 6px 12px; border-radius: 6px;
			text-align: center; min-width: 70px;
		}
		.info-label { 
			opacity: 0.8; font-weight: normal;
		}
		#score, #level {
			font-weight: bold; font-size: 1.1em;
		}
		#restart-btn-top {
			flex: 0 0 auto; padding: 6px 12px; font-size: 1.2em;
			background: #f44; color: #fff; border: none; border-radius: 6px;
			cursor: pointer; min-width: 50px; height: 36px;
			display: flex; align-items: center; justify-content: center;
		}
		canvas {
			border: 4px solid #333; border-radius: 0 0 8px 8px;
			image-rendering: pixelated;
			background: #111;
			touch-action: none;
			max-width: 100%; margin: 0;
			border-top: none;
		}
		#bottom-panel {
			width: 100%; max-width: 400px; margin-top: 15px;
		}
		#controls {
			display: grid; 
			grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr; 
			grid-template-rows: 1fr 1fr; 
			gap: 6px;
			width: 100%;
		}
		.ctrl-btn {
			padding: 12px 8px; font-size: 1.6em; background: #0af; color: #000;
			border: none; border-radius: 10px; cursor: pointer;
			user-select: none; touch-action: manipulation;
			font-weight: bold; transition: all 0.1s;
			display: flex; align-items: center; justify-content: center;
		}
		.ctrl-btn:active { background: #0cf; transform: scale(0.92); }
		#pause-btn {
			grid-column: 6; grid-row: 1;
		}
		#pause-btn.paused { background: #8f0; }
		#left { grid-column: 1; grid-row: 1; }
		#rotate { grid-column: 2; grid-row: 1; }
		#right { grid-column: 3; grid-row: 1; }
		#softdrop { grid-column: 4; grid-row: 1; }
		#harddrop { grid-column: 5; grid-row: 1; }
		.ctrl-btn:hover { filter: brightness(1.15); }
		@media (min-width: 600px) {
			#game { flex-direction: row; justify-content: center; gap: 20px; }
			canvas { width: 400px; height: 600px; }
			#top-panel, #bottom-panel { width: auto; }
			#controls { width: 280px; }
			#info { gap: 15px; padding: 10px 15px; }
		}
	</style>
</head>
<body>
	<div id="game">
		<!-- ÊúÄ‰∏äÊñπÔºöÂàÜÊï∏‰ΩîÊõ¥Â§öÁ©∫Èñì -->
		<div id="top-panel">
			<div id="info">
				<div id="score-item" class="info-item">
					<span class="info-label">ÂàÜÊï∏</span><span id="score">0</span>
				</div>
				<div id="level-item" class="info-item">
					<span class="info-label">Á≠âÁ¥ö</span><span id="level">1</span>
				</div>
				<button id="restart-btn-top">‚è∫Ô∏è</button>
			</div>
		</div>

		<!-- ÈÅäÊà≤Áï´Â∏ÉÔºàËàá‰∏äÊñπÁÑ°Á∏´ÈÄ£Êé•Ôºâ -->
		<canvas id="tetris" width="400" height="500"></canvas>
		
		<!-- ÊúÄ‰∏ãÊñπÔºöÂÖ©Ë°åÂÖ® ICON ÊåâÈàï -->
		<div id="bottom-panel">
			<div id="controls">
				<button class="ctrl-btn" id="left">‚¨ÖÔ∏è</button>
				<button class="ctrl-btn" id="rotate">üîÑ</button>
				<button class="ctrl-btn" id="right">‚û°Ô∏è</button>
				<button class="ctrl-btn" id="softdrop">‚¨áÔ∏è</button>
				<button class="ctrl-btn" id="harddrop">‚è¨</button>
				<button class="ctrl-btn" id="pause-btn">‚è∏Ô∏è</button>
			</div>
		</div>
	</div>

	<script>
		const canvas = document.getElementById('tetris');
		const ctx = canvas.getContext('2d');
		ctx.scale(20, 20);

		const scoreEl = document.getElementById('score');
		const levelEl = document.getElementById('level');
		const pauseBtn = document.getElementById('pause-btn');
		const restartBtnTop = document.getElementById('restart-btn-top');

		const ROW = 25;
		const COL = 20;
		const SQ = 1;
		const VACANT = 'black';

		const PIECES = [
			[[[1,1,0],[0,1,1]], 'red'],     // Z
			[[[0,1,1],[1,1,0]], 'lime'],    // S
			[[[0,1,0],[1,1,1]], 'purple'],  // T
			[[[1,1],[1,1]], 'yellow'],      // O
			[[[1,0,0],[1,1,1]], 'orange'],  // L
			[[[1,1,1,1]], 'cyan'],          // I
			[[[0,0,1],[1,1,1]], 'blue']     // J
		];

		const ROTATIONS = {
			Z: [[[1,1,0],[0,1,1]], [[0,1],[1,1],[1,0]], [[1,1,0],[0,1,1]], [[0,1],[1,1],[1,0]]],
			S: [[[0,1,1],[1,1,0]], [[1,0],[1,1],[0,1]], [[0,1,1],[1,1,0]], [[1,0],[1,1],[0,1]]],
			T: [[[0,1,0],[1,1,1]], [[1,0],[1,1],[1,0]], [[1,1,1],[0,1,0]], [[0,1],[1,1],[0,1]]],
			O: [[[1,1],[1,1]], [[1,1],[1,1]], [[1,1],[1,1]], [[1,1],[1,1]]],
			L: [[[1,0,0],[1,1,1]], [[1,1],[1,0],[1,0]], [[1,1,1],[0,0,1]], [[0,1],[0,1],[1,1]]],
			I: [[[1,1,1,1]], [[1],[1],[1],[1]], [[1,1,1,1]], [[1],[1],[1],[1]]],
			J: [[[0,0,1],[1,1,1]], [[1,0],[1,0],[1,1]], [[1,1,1],[1,0,0]], [[1,1],[0,1],[0,1]]]
		};

		let board = Array.from({length: ROW}, () => Array(COL).fill(VACANT));
		let score = 0, level = 1;
		let dropStart = Date.now();
		let gameOver = false;
		let isPaused = false;
		let currentPiece = createPiece();

		function createPiece() {
			const idx = Math.floor(Math.random() * PIECES.length);
			const [shape, color] = PIECES[idx];
			const type = ['Z','S','T','O','L','I','J'][idx];
			return {
				matrix: shape,
				color: color,
				type: type,
				x: Math.floor(COL / 2) - Math.floor(shape[0].length / 2),
				y: 0,
				rotation: 0
			};
		}

		function drawSquare(x, y, color) {
			ctx.fillStyle = color;
			ctx.fillRect(x, y, SQ, SQ);
			ctx.strokeStyle = '#000';
			ctx.lineWidth = 0.05;
			ctx.strokeRect(x, y, SQ, SQ);
		}

		function drawBoard() {
			for (let r = 0; r < ROW; r++) {
				for (let c = 0; c < COL; c++) {
					drawSquare(c, r, board[r][c]);
				}
			}
		}

		function drawPiece() {
			currentPiece.matrix.forEach((row, y) => {
				row.forEach((value, x) => {
					if (value) {
						drawSquare(currentPiece.x + x, currentPiece.y + y, currentPiece.color);
					}
				});
			});
		}

		function collide() {
			for (let y = 0; y <currentPiece.matrix.length; y++) {
				for (let x = 0; x < currentPiece.matrix[y].length; x++) {
					if (currentPiece.matrix[y][x] &&
						(board[currentPiece.y + y] === undefined ||
						 board[currentPiece.y + y][currentPiece.x + x] === undefined ||
						 board[currentPiece.y + y][currentPiece.x + x] !== VACANT)) {
						return true;
					}
				}
			}
			return false;
		}

		function merge() {
			currentPiece.matrix.forEach((row, y) => {
				row.forEach((value, x) => {
					if (value) {
						board[currentPiece.y + y][currentPiece.x + x] = currentPiece.color;
					}
				});
			});
		}

		function rotate() {
			const nextRotation = (currentPiece.rotation + 1) % 4;
			const nextMatrix = ROTATIONS[currentPiece.type][nextRotation];
			const originalX = currentPiece.x;

			const kicks = [0, 1, -1, 2, -2];
			for (const kick of kicks) {
				currentPiece.x = originalX + kick;
				currentPiece.matrix = nextMatrix;
				if (!collide()) {
					currentPiece.rotation = nextRotation;
					return;
				}
			}
			currentPiece.x = originalX;
		}

		function playerDrop() {
			currentPiece.y++;
			if (collide()) {
				currentPiece.y--;
				merge();
				clearLines();
				currentPiece = createPiece();
				dropStart = Date.now();
				if (collide()) {
					gameOver = true;
					setTimeout(() => alert(`ÈÅäÊà≤ÁµêÊùüÔºÅ\nÊúÄÁµÇÂàÜÊï∏Ôºö${score}`), 100);
				}
			}
		}

		function playerHardDrop() {
			while (!collide()) currentPiece.y++;
			currentPiece.y--;
			playerDrop();
		}

		function playerMove(dir) {
			currentPiece.x += dir;
			if (collide()) currentPiece.x -= dir;
		}

		function clearLines() {
			let linesCleared = 0;
			outer: for (let y = ROW - 1; y >= 0; y--) {
				for (let x = 0; x < COL; x++) {
					if (!board[y][x] || board[y][x] === VACANT) continue outer;
				}
				board.splice(y, 1);
				board.unshift(Array(COL).fill(VACANT));
				linesCleared++;
				y++;
			}
			if (linesCleared > 0) {
				const points = [0, 100, 300, 500, 800];
				score += points[linesCleared] * level;
				level = Math.floor(score / 1000) + 1;
				updateScore();
			}
		}

		function updateScore() {
			scoreEl.textContent = score;
			levelEl.textContent = level;
		}

		function togglePause() {
			isPaused = !isPaused;
			pauseBtn.textContent = isPaused ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è';
			pauseBtn.classList.toggle('paused', isPaused);
		}

		function restartGame() {
			board = Array.from({length: ROW}, () => Array(COL).fill(VACANT));
			score = 0; level = 1;
			currentPiece = createPiece();
			gameOver = false;
			isPaused = false;
			pauseBtn.textContent = '‚è∏Ô∏è';
			pauseBtn.classList.remove('paused');
			updateScore();
			dropStart = Date.now();
			update();
		}

		function update() {
			if (gameOver || isPaused) {
				requestAnimationFrame(update);
				return;
			}

			ctx.fillStyle = '#111';
			ctx.fillRect(0, 0, COL, ROW);
			drawBoard();
			drawPiece();

			const now = Date.now();
			const dropInterval = Math.max(100, 1000 - (level - 1) * 100);
			if (now - dropStart > dropInterval) {
				playerDrop();
				dropStart = now;
			}

			requestAnimationFrame(update);
		}

		// === Ëß∏ÊéßÊåâÈàïÊéßÂà∂ ===
		document.getElementById('left').addEventListener('click', () => {
			if (!gameOver && !isPaused) playerMove(-1);
		});
		document.getElementById('right').addEventListener('click', () => {
			if (!gameOver && !isPaused) playerMove(1);
		});
		document.getElementById('rotate').addEventListener('click', () => {
			if (!gameOver && !isPaused) rotate();
		});
		document.getElementById('softdrop').addEventListener('click', () => {
			if (!gameOver && !isPaused) playerDrop();
		});
		document.getElementById('harddrop').addEventListener('click', () => {
			if (!gameOver && !isPaused) playerHardDrop();
		});

		// Èï∑ÊåâÂä†ÈÄü
		let softDropInterval;
		const softdropBtn = document.getElementById('softdrop');
		softdropBtn.addEventListener('touchstart', e => {
			e.preventDefault();
			if (gameOver || isPaused) return;
			playerDrop();
			softDropInterval = setInterval(() => {
				if (!gameOver && !isPaused) playerDrop();
			}, 50);
		});
		['touchend', 'mouseup', 'mouseleave'].forEach(ev => {
			softdropBtn.addEventListener(ev, () => clearInterval(softDropInterval));
		});

		// === PAUSE ÂäüËÉΩ ===
		pauseBtn.addEventListener('click', togglePause);

		// === ÈáçÊñ∞ÈñãÂßãÔºàÂÉÖ‰∏äÊñπÔºâ ===
		restartBtnTop.addEventListener('click', restartGame);

		// === ÈçµÁõ§ÊéßÂà∂Ôºà‰øùÁïôÔºâ ===
		document.addEventListener('keydown', e => {
			if (gameOver || isPaused) return;
			if (e.key === 'ArrowLeft') playerMove(-1);
			if (e.key === 'ArrowRight') playerMove(1);
			if (e.key === 'ArrowDown') playerDrop();
			if (e.key === 'ArrowUp') rotate();
			if (e.key === ' ') { e.preventDefault(); playerHardDrop(); }
			if (e.key === 'p' || e.key === 'P') togglePause();
			if (e.key === 'r' || e.key === 'R') restartGame();
		});

		// ÂàùÂßãÂåñ
		updateScore();
		update();
	</script>
</body>
</html>