<!DOCTYPE html>
<html lang="zh-HK">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
	<title>Vanilla JS Tetris（觸控控制版）</title>
	<style>
		body {
			margin: 0; padding: 0; background: #0a0a0a; color: #fff;
			font-family: 'Courier New', monospace;
			display: flex; flex-direction: column; justify-content: center; align-items: center;
			min-height: 100vh; overflow: hidden; padding: 10px; box-sizing: border-box;
		}
		#game {
			display: flex; flex-direction: column; align-items: center; gap: 15px;
		}
		canvas {
			border: 4px solid #333; border-radius: 8px;
			image-rendering: pixelated;
			background: #111;
			touch-action: none;
		}
		#info {
			text-align: center; font-size: 1.2em; width: 100%; max-width: 400px;
		}
		#controls {
			display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-top: 10px;
			width: 100%; max-width: 400px;
		}
		.ctrl-btn {
			padding: 16px; font-size: 1.4em; background: #0af; color: #000;
			border: none; border-radius: 8px; cursor: pointer;
			user-select: none; touch-action: manipulation;
			font-weight: bold;
		}
		.ctrl-btn:active { background: #0cf; transform: scale(0.95); }
		.ctrl-btn.wide { grid-column: span 3; }
		button {
			margin-top: 10px; padding: 10px 20px; font-size: 1em;
			background: #0af; color: #000; border: none; border-radius: 4px;
			cursor: pointer; width: 100%; max-width: 400px;
		}
		button:hover, .ctrl-btn:hover { background: #0cf; }
		@media (min-width: 600px) {
			#game { flex-direction: row; }
			#info, #controls { width: auto; }
			#controls { width: 180px; }
		}
	</style>
</head>
<body>
	<div id="game">
		<canvas id="tetris" width="300" height="500"></canvas>
		
		<div id="info">
			<div>分數: <span id="score">0</span></div>
			<div>等級: <span id="level">1</span></div>
			<div>行數: <span id="lines">0</span></div>
			<button id="restart">重新開始</button>
		</div>
	</div>

	<div id="controls">
		<div class="ctrl-btn" id="left">←</div>
		<div class="ctrl-btn" id="rotate">↑</div>
		<div class="ctrl-btn" id="right">→</div>
		<div class="ctrl-btn wide" id="harddrop">硬降（空格）</div>
		<div class="ctrl-btn wide" id="softdrop">加速（↓）</div>
	</div>

	<script>
		const canvas = document.getElementById('tetris');
		const ctx = canvas.getContext('2d');
		ctx.scale(20, 20);

		const scoreEl = document.getElementById('score');
		const levelEl = document.getElementById('level');
		const linesEl = document.getElementById('lines');
		const restartBtn = document.getElementById('restart');

		const ROW = 25;
		const COL = 15;  // 改為 15 格寬，適合手機
		const SQ = 1;
		const VACANT = 'black';

		const PIECES = [
			[[[1,1,0],[0,1,1]], 'red'],     // Z
			[[[0,1,1],[1,1,0]], 'lime'],    // S
			[[[0,1,0],[1,1,1]], 'purple'],  // T
			[[[1,1],[1,1]], 'yellow'],      // O
			[[[1,0,0],[1,1,1]], 'orange'],  // L
			[[[1,1,1,1]], 'cyan'],          // I
			[[[0,0,1],[1,1,1]], 'blue']     // J
		];

		const ROTATIONS = {
			Z: [[[1,1,0],[0,1,1]], [[0,1],[1,1],[1,0]], [[1,1,0],[0,1,1]], [[0,1],[1,1],[1,0]]],
			S: [[[0,1,1],[1,1,0]], [[1,0],[1,1],[0,1]], [[0,1,1],[1,1,0]], [[1,0],[1,1],[0,1]]],
			T: [[[0,1,0],[1,1,1]], [[1,0],[1,1],[1,0]], [[1,1,1],[0,1,0]], [[0,1],[1,1],[0,1]]],
			O: [[[1,1],[1,1]], [[1,1],[1,1]], [[1,1],[1,1]], [[1,1],[1,1]]],
			L: [[[1,0,0],[1,1,1]], [[1,1],[1,0],[1,0]], [[1,1,1],[0,0,1]], [[0,1],[0,1],[1,1]]],
			I: [[[1,1,1,1]], [[1],[1],[1],[1]], [[1,1,1,1]], [[1],[1],[1],[1]]],
			J: [[[0,0,1],[1,1,1]], [[1,0],[1,0],[1,1]], [[1,1,1],[1,0,0]], [[1,1],[0,1],[0,1]]]
		};

		let board = Array.from({length: ROW}, () => Array(COL).fill(VACANT));
		let score = 0, lines = 0, level = 1;
		let dropStart = Date.now();
		let gameOver = false;
		let currentPiece = createPiece();

		function createPiece() {
			const idx = Math.floor(Math.random() * PIECES.length);
			const [shape, color] = PIECES[idx];
			const type = ['Z','S','T','O','L','I','J'][idx];
			return {
				matrix: shape,
				color: color,
				type: type,
				x: Math.floor(COL / 2) - Math.floor(shape[0].length / 2),
				y: 0,
				rotation: 0
			};
		}

		function drawSquare(x, y, color) {
			ctx.fillStyle = color;
			ctx.fillRect(x, y, SQ, SQ);
			ctx.strokeStyle = '#000';
			ctx.lineWidth = 0.05;
			ctx.strokeRect(x, y, SQ, SQ);
		}

		function drawBoard() {
			for (let r = 0; r < ROW; r++) {
				for (let c = 0; c < COL; c++) {
					drawSquare(c, r, board[r][c]);
				}
			}
		}

		function drawPiece() {
			currentPiece.matrix.forEach((row, y) => {
				row.forEach((value, x) => {
					if (value) {
						drawSquare(currentPiece.x + x, currentPiece.y + y, currentPiece.color);
					}
				});
			});
		}

		function collide() {
			for (let y = 0; y < currentPiece.matrix.length; y++) {
				for (let x = 0; x < currentPiece.matrix[y].length; x++) {
					if (currentPiece.matrix[y][x] &&
						(board[currentPiece.y + y] === undefined ||
						 board[currentPiece.y + y][currentPiece.x + x] === undefined ||
						 board[currentPiece.y + y][currentPiece.x + x] !== VACANT)) {
						return true;
					}
				}
			}
			return false;
		}

		function merge() {
			currentPiece.matrix.forEach((row, y) => {
				row.forEach((value, x) => {
					if (value) {
						board[currentPiece.y + y][currentPiece.x + x] = currentPiece.color;
					}
				});
			});
		}

		function rotate() {
			const nextRotation = (currentPiece.rotation + 1) % 4;
			const nextMatrix = ROTATIONS[currentPiece.type][nextRotation];
			const originalX = currentPiece.x;

			const kicks = [0, 1, -1, 2, -2];
			for (const kick of kicks) {
				currentPiece.x = originalX + kick;
				currentPiece.matrix = nextMatrix;
				if (!collide()) {
					currentPiece.rotation = nextRotation;
					return;
				}
			}
			currentPiece.x = originalX;
		}

		function playerDrop() {
			currentPiece.y++;
			if (collide()) {
				currentPiece.y--;
				merge();
				clearLines();
				currentPiece = createPiece();
				dropStart = Date.now();
				if (collide()) {
					gameOver = true;
					setTimeout(() => alert(`遊戲結束！\n最終分數：${score}`), 100);
				}
			}
		}

		function playerHardDrop() {
			while (!collide()) currentPiece.y++;
			currentPiece.y--;
			playerDrop();
		}

		function playerMove(dir) {
			currentPiece.x += dir;
			if (collide()) currentPiece.x -= dir;
		}

		function clearLines() {
			let linesCleared = 0;
			outer: for (let y = ROW - 1; y >= 0; y--) {
				for (let x = 0; x < COL; x++) {
					if (!board[y][x] || board[y][x] === VACANT) continue outer;
				}
				board.splice(y, 1);
				board.unshift(Array(COL).fill(VACANT));
				linesCleared++;
				y++;
			}
			if (linesCleared > 0) {
				const points = [0, 100, 300, 500, 800];
				score += points[linesCleared] * level;
				lines += linesCleared;
				level = Math.floor(lines / 10) + 1;
				updateScore();
			}
		}

		function updateScore() {
			scoreEl.textContent = score;
			levelEl.textContent = level;
			linesEl.textContent = lines;
		}

		function update() {
			if (gameOver) return;

			ctx.fillStyle = '#111';
			ctx.fillRect(0, 0, COL, ROW);
			drawBoard();
			drawPiece();

			const now = Date.now();
			const dropInterval = Math.max(100, 1000 - (level - 1) * 100);
			if (now - dropStart > dropInterval) {
				playerDrop();
				dropStart = now;
			}

			requestAnimationFrame(update);
		}

		// === 觸控按鈕控制 ===
		document.getElementById('left').addEventListener('click', () => playerMove(-1));
		document.getElementById('right').addEventListener('click', () => playerMove(1));
		document.getElementById('rotate').addEventListener('click', rotate);
		document.getElementById('softdrop').addEventListener('click', playerDrop);
		document.getElementById('harddrop').addEventListener('click', playerHardDrop);

		// 長按加速（可選）
		let softDropInterval;
		document.getElementById('softdrop').addEventListener('touchstart', e => {
			e.preventDefault();
			playerDrop();
			softDropInterval = setInterval(playerDrop, 50);
		});
		document.getElementById('softdrop').addEventListener('touchend', () => clearInterval(softDropInterval));
		document.getElementById('softdrop').addEventListener('mousedown', () => {
			playerDrop();
			softDropInterval = setInterval(playerDrop, 50);
		});
		document.getElementById('softdrop').addEventListener('mouseup', () => clearInterval(softDropInterval));
		document.getElementById('softdrop').addEventListener('mouseleave', () => clearInterval(softDropInterval));

		// === 鍵盤控制（保留）===
		document.addEventListener('keydown', e => {
			if (gameOver) return;
			if (e.key === 'ArrowLeft') playerMove(-1);
			if (e.key === 'ArrowRight') playerMove(1);
			if (e.key === 'ArrowDown') playerDrop();
			if (e.key === 'ArrowUp') rotate();
			if (e.key === ' ') { e.preventDefault(); playerHardDrop(); }
		});

		// === 重新開始 ===
		restartBtn.addEventListener('click', () => {
			board = Array.from({length: ROW}, () => Array(COL).fill(VACANT));
			score = 0; lines = 0; level = 1;
			currentPiece = createPiece();
			gameOver = false;
			updateScore();
			dropStart = Date.now();
			update();
		});

		// 初始化
		updateScore();
		update();
	</script>
</body>
</html>